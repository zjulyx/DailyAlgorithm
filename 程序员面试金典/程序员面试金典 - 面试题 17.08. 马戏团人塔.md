> 题目难度: 中等

> [原题链接](https://leetcode-cn.com/problems/circus-tower-lcci/)

> 今天继续更新程序员面试金典系列, 大家在公众号 **算法精选** 里回复 **面试金典** 就能看到该系列当前连载的所有文章了, 记得关注哦~

## 题目描述

有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。

### 示例：

- 输入：height = [65,70,56,75,60,68] weight = [100,150,90,190,95,110]
- 输出：6
- 解释：从上往下数，叠罗汉最多能叠 6 层：(56,90), (60,95), (65,100), (68,110), (70,150), (75,190)

### 提示：

- height.length == weight.length <= 10000

## 题目思考

1. 如何简化问题?

## 解决方案

### 思路

- 分析题目, 一个比较容易想到的思路就是两重 DP, 即:
  1. dp[i]代表截至 i 的最大叠放人数
  2. 然后内层循环 i 之前的人, 如果某人 j 更矮更轻, 则更新 dp[i]为它和 dp[j]+1 的较大值
  3. 最后 dp 的最大值即为结果
- 但这种方法复杂度达到了 O(N^2), 根据题目规模会超时, 有没有更优的方案呢?
- 这里有身高和体重两个维度, 如果我们可以将其降成一维, 那么就可以转换成经典的最长递增子序列([LIS](https://baike.baidu.com/item/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/22828111?fr=aladdin))问题了
- 那如何降维呢? 如果我们直接将每个人的身高体重作为一个元组, 然后对其排序, 那么看上去只需要关注体重这一个维度就行了, 因为身高已经自动满足要求
- 但这里隐含了一个**错误**, 假设输入只有两个人: [180,60]和[180,80], 那按照上述算法, 最终结果会同时包含这两个人, 因为其体重是递增的, 但这显然是错误的: 因为他们身高相同, 不能叠放
- 所以我们必须排除相同身高下的体重递增情况, 也就是说**按照身高升序排列, 然后身高相同时按照体重降序排列**
- 这样我们就成功降成了体重一个维度, 接下来只需要应用经典的最长递增子序列算法即可:
  1. 维护一个有序列表, 代表目前最长的递增子序列
  2. 遍历当前元素时, 二分查找有序列表中第一个大于等于它的下标
  3. 若其比所有已有数字都大, 则追加它; 否则更新对应下标为它, 这样后面的判断里都可以基于这个更小值来追加, 比之前该下标保存的值更优
  4. 遍历结束时有序列表的长度即为整个列表最长的递增子序列长度了
- 下面的代码中对每个步骤都有注释, 方便大家理解

### 复杂度

- 时间复杂度 O(NlogN): 排序以及遍历加二分都是 NlogN 的复杂度
- 空间复杂度 O(N): 使用多个长度为 N 的列表

### 代码

```python
class Solution:
    def bestSeqAtIndex(self, height: List[int], weight: List[int]) -> int:
        # 固定维度a升序排列, 然后相同时维度b逆序排列, 这样只需要对b求最长递增子序列即可
        # 因为a相同的时候b逆序, 递增序列最多只可能选择其中的一个b, 所以最终递增序列中一定不可能出现某两个a相同的情况
        # 构造(身高,体重)元组列表
        tuples = []
        for h, w in zip(height, weight):
            tuples.append((h, w))
        # 身高升序, 体重降序排列
        tuples.sort(key=lambda t: (t[0], -t[1]))
        weights = [t[1] for t in tuples]
        # 有序列表
        sarr = []
        for w in weights:
            # j是列表中大于等于w的最小下标 (可能等于列表长度)
            j = bisect.bisect_left(sarr, w)
            if j >= len(sarr):
                # w比任意已有数字都大, 追加它
                sarr.append(w)
            else:
                # 否则更新对应下标的数字为w, 因为w总小于等于当前值
                sarr[j] = w
        # 最后有序列表的长度即为整个列表最长的递增子序列长度了
        return len(sarr)
```

---

> 大家可以在下面这些地方找到我~😊

> [我的 GitHub](https://github.com/zjulyx)

> [我的 Leetcode](https://leetcode-cn.com/u/suibianfahui/)

> [我的 CSDN](https://me.csdn.net/zjulyx1993)

> [我的知乎专栏](https://zhuanlan.zhihu.com/c_1242508721932464128)

> [我的头条号](https://www.toutiao.com/c/user/1090304683804520/#mid=1671643017345028)

> [我的牛客网博客](https://blog.nowcoder.net/zjulyx)

> 我的公众号: [算法精选](https://mp.weixin.qq.com/s?__biz=MzA5MDk1MjI5MA==&mid=2247484158&idx=1&sn=90176bac32cf7af40e4074c721fd8a95&chksm=900285f3a7750ce5a068c9c9773781461819633f2fd60533732637ec9520c908371ebc218d49&scene=178&cur_album_id=1386231241346859009#rd), 欢迎大家扫码关注~😊

![算法精选 - 微信扫一扫关注我](https://pic1.zhimg.com/80/v2-7c988a7b35886df51596ef23616764ac_1440w.jpg)
