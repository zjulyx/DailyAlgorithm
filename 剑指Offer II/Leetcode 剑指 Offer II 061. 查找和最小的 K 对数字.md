> 题目难度: 中等

> [原题链接](https://leetcode.cn/problems/qn8gGX/)

> 今天继续更新 Leetcode 的剑指 Offer（专项突击版）系列, 大家在公众号 **算法精选** 里回复 `剑指offer2` 就能看到该系列当前连载的所有文章了, 记得关注哦~

## 题目描述

给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。

请找到和最小的 k 个数对 (u1,v1), (u2,v2) ... (uk,vk) 。

### 示例 1:

- 输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
- 输出: [1,2],[1,4],[1,6]
- 解释: 返回序列中的前 3 对数：[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]

### 示例 2:

- 输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
- 输出: [1,1],[1,1]
- 解释: 返回序列中的前 2 对数：[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]

### 示例 3:

- 输入: nums1 = [1,2], nums2 = [3], k = 3
- 输出: [1,3],[2,3]
- 解释: 也可能序列中所有的数对都被返回:[1,3],[2,3]

### 提示:

- 1 <= nums1.length, nums2.length <= 10^4
- -10^9 <= nums1[i], nums2[i] <= 10^9
- nums1, nums2 均为升序排列
- 1 <= k <= 1000

## 题目思考

1. 如何尽可能优化复杂度?

## 解决方案

#### 思路

- 分析题目, 一个很容易想到的思路就是枚举所有的数字对, 然后对它们的和进行排序, 最小的 k 对即为所求
- 不过这种方法的复杂度达到了 O(n^2logn), 有没有更优的方法呢?
- 题目要求最小的 k 对数字, 这不难联想到前面的题目[Leetcode 剑指 Offer II 059. 数据流中的第 K 大元素](https://mp.weixin.qq.com/s?__biz=MzA5MDk1MjI5MA==&mid=2247484722&idx=1&sn=ca9f648d8db7750f332f2685f3244a49&token=1962459982&lang=zh_CN#rd), 我们这里也可以利用类似的思路, 将排序转换成大小为 k 的最大堆, 这样遍历完所有数字对后, 堆中的 k 个数字对就是最终结果, 这样复杂度来到了 O(n^2logk), 是否还能进一步优化呢?
- 上面的思路都没有利用题目中升序排列这一条件, 由于两个数组都是升序排列, 显然下标`[0,0]`的数字对就是最小的, 次小的则一定只可能是下标`[0,1]`或者`[1,0]`, 这就引出了下面的思路:
  - 维护一个最小堆, 存储三元组[数字对之和, 第一个数组下标, 第二个数组下标], 简写为`[sm,i,j]`
  - 初始化将下标`[0,0]`对应的三元组加入堆中
  - 然后开始循环, 弹出堆顶`[sm,i,j]`, 将对应数字对`[nums[i],nums[j]]`加入最终结果中, 并将紧邻它的数字对`[i+1,j]`和`[i,j+1]`各自对应的三元组加入堆中
  - 特别注意, 数字对可能被重复添加, 例如堆顶`[1,2]`和堆顶`[2,1]`同样都有紧邻数字对`[2,2]`
  - 所以我们需要额外的集合来存储已经加入堆中的数字对, 如果该数字对已经在集合中, 就不再重复添加
  - 这样不断循环, 直到最终结果的长度达到 k, 或者堆变空时结束
- 通过上述做法, 我们只需要循环 k 次, 而每次对堆的操作都只需要 O(logk), 从而成功将复杂度降低到了 O(klogk)
- 下面代码中有详细的注释, 方便大家理解

#### 复杂度

- 时间复杂度 O(klogk): 只需要循环 k 次, 而每次对堆的操作都只需要 O(logk), 所以整体是 O(klogk)
- 空间复杂度 O(k): 堆和集合都需要存储 k 个元素

#### 代码

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        # 注意可能添加重复元素, 所以需要v集合
        if not nums1 or not nums2:
            # 没有符合要求的数字对
            return []
        res = []
        # 最小堆初始时存储[0,0]对应的三元组
        pq = [(nums1[0] + nums2[0], 0, 0)]
        # 集合初始化存储下标对(0,0)
        v = {(0, 0)}
        while len(res) < k and pq:
            # 弹出当前最小的数字对, 并将其追加到最终结果中
            _, i, j = heapq.heappop(pq)
            res.append([nums1[i], nums2[j]])
            for ii, jj in ((i + 1, j), (i, j + 1)):
                # 将尚未遍历的紧邻数字对加入堆和集合中
                if ii < len(nums1) and jj < len(nums2) and (ii, jj) not in v:
                    v.add((ii, jj))
                    heapq.heappush(pq, (nums1[ii] + nums2[jj], ii, jj))
        return res
```

---

> 大家可以在下面这些地方找到我~😊

> [我的 GitHub](https://github.com/zjulyx)

> [我的 Leetcode](https://leetcode-cn.com/u/suibianfahui/)

> [我的 CSDN](https://me.csdn.net/zjulyx1993)

> [我的知乎专栏](https://zhuanlan.zhihu.com/c_1242508721932464128)

> [我的头条号](https://www.toutiao.com/c/user/1090304683804520/#mid=1671643017345028)

> [我的牛客网博客](https://blog.nowcoder.net/zjulyx)

> 我的公众号: [算法精选](https://mp.weixin.qq.com/s?__biz=MzA5MDk1MjI5MA==&mid=2247484158&idx=1&sn=90176bac32cf7af40e4074c721fd8a95&chksm=900285f3a7750ce5a068c9c9773781461819633f2fd60533732637ec9520c908371ebc218d49&scene=178&cur_album_id=1386231241346859009#rd), 欢迎大家扫码关注~😊

![算法精选 - 微信扫一扫关注我](https://pic1.zhimg.com/80/v2-7c988a7b35886df51596ef23616764ac_1440w.jpg)
