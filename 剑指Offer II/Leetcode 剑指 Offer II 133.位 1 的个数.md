> 题目难度: 简单

> [原题链接](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

> 今天继续更新 Leetcode 的剑指 Offer（专项突击版）系列, 大家在公众号 **算法精选** 里回复 `剑指offer2` 就能看到该系列当前连载的所有文章了, 记得关注哦~

## 题目描述

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）。

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

### 示例 1：

- 输入：n = 11 (控制台输入 00000000000000000000000000001011)
- 输出：3
- 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

### 示例 2：

- 输入：n = 128 (控制台输入 00000000000000000000000010000000)
- 输出：1
- 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

### 示例 3：

- 输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）
- 输出：31
- 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

### 提示：

- 输入必须是长度为 32 的 二进制串 。

## 题目思考

1. 可以使用哪些位运算?
2. 不用位运算可以吗?

## 解决方案

### 方案 1 & 2 - 直接统计 1 的个数

#### 分析

- 最直观的思路就是直接统计二进制数字里 1 的个数

#### 实现

1. 方案 1: 转成二进制字符串统计'1'的个数
2. 方案 2: 移位, 根据最低位是否为 1 来统计. 注意题目是 32 位整数, 所以限制移位次数为 32 次, 避免负数的高位一直为 1 即可

#### 复杂度

- 时间复杂度 `O(logN)`
  - 数字 N 的位数为`logN`, 需要遍历这么多次
- 空间复杂度 `O(1)`
  - 只使用了几个变量

#### 代码

##### 方案 1: 转二进制字符串统计 1

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        # 方法1: 转二进制字符串统计1
        return bin(n).count('1')
```

##### 方案 2: 循环移位统计 1

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        # 方法2: 循环移位统计1
        res = 0
        for i in range(32):
            if n == 0:
                break
            res += n & 1
            n >>= 1
        return res
```

### 方案 3 & 4 - 利用位运算统计 1 的个数

#### 分析

- 如果我们能直接定位到 1, 然后每次都把已经统计的 1 排除掉的话, 就只需要操作 1 的个数次, 而不需要遍历所有位了

#### 实现

1. 方案 3: 利用 `n & (n-1)`. 大家可以想象一下 n-1 在二进制上所做的操作: 其实就是把 n 的最低一位的 1 转成 0, 然后后面的 0 都转成 1, 高位保持不变, 这样它们的 `&` 值自然就会去掉最低位的 1. 这样循环操作, 最终就会去掉所有 1, 得到 0, 操作的次数也即 1 的个数了.
2. 方案 4: 利用 `n & -n`. 熟悉树状数组的同学可能会比较清楚这个表达式, 这个就是 lowbit. 通俗点说它相比 n, 只保留最低位的 1, 其他位全清 0. 这个同样可以根据 `-n` 的二进制含义得出, 补码与原数的 `&` 的结果会正好只留最低位的 1. 然后将 n 减去这个 lowbit, 就等于去掉了一个 1, 循环最终会得到 0, 操作的次数也即 1 的个数了.

#### 复杂度

- 时间复杂度 `O(M)`
  - 设数字有 `M` 位 1, 需要遍历这么多次
- 空间复杂度 `O(1)`
  - 只使用了几个变量

#### 代码

##### 方案 3: n &= n - 1

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        # 方法3: n &= n - 1
        res = 0
        while n:
            n &= n - 1
            res += 1
        return res
```

##### 方案 4: n -= n & -n

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        # 方法4: n -= n & -n
        res = 0
        while n:
            n -= n & -n
            res += 1
        return res
```

---

> 大家可以在下面这些地方找到我~😊

> [我的 GitHub](https://github.com/zjulyx)

> [我的 Leetcode](https://leetcode-cn.com/u/suibianfahui/)

> [我的 CSDN](https://me.csdn.net/zjulyx1993)

> [我的知乎专栏](https://zhuanlan.zhihu.com/c_1242508721932464128)

> [我的头条号](https://www.toutiao.com/c/user/1090304683804520/#mid=1671643017345028)

> [我的牛客网博客](https://blog.nowcoder.net/zjulyx)

> 我的公众号: [算法精选](https://mp.weixin.qq.com/s?__biz=MzA5MDk1MjI5MA==&mid=2247484158&idx=1&sn=90176bac32cf7af40e4074c721fd8a95&chksm=900285f3a7750ce5a068c9c9773781461819633f2fd60533732637ec9520c908371ebc218d49&scene=178&cur_album_id=1386231241346859009#rd), 欢迎大家扫码关注~😊

![算法精选 - 微信扫一扫关注我](https://pic1.zhimg.com/80/v2-7c988a7b35886df51596ef23616764ac_1440w.jpg)
