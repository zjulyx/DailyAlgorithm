> 题目难度: 困难

> [原题链接](https://leetcode.cn/problems/H6lPxb/)

> 今天继续更新 Leetcode 的剑指 Offer（专项突击版）系列, 大家在公众号 **算法精选** 里回复 `剑指offer2` 就能看到该系列当前连载的所有文章了, 记得关注哦~

## 题目描述

如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。

例如，"tars" 和 "rats" 是相似的 (交换 0 与 2 的位置)； "rats" 和 "arts" 也是相似的，但是 "star" 不与 "tars"，"rats"，或 "arts" 相似。

总之，它们通过相似性形成了两个关联组：{"tars", "rats", "arts"} 和 {"star"}。注意，"tars" 和 "arts" 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。

给定一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个 字母异位词 。请问 strs 中有多少个相似字符串组？

字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。

### 示例 1：

- 输入：strs = ["tars","rats","arts","star"]
- 输出：2

### 示例 2：

- 输入：strs = ["omv","ovm"]
- 输出：1

### 提示：

- 1 <= strs.length <= 300
- 1 <= strs[i].length <= 300
- strs[i] 只包含小写字母。
- strs 中的所有单词都具有相同的长度，且是彼此的字母异位词。

## 题目思考

1. 可以使用什么数据结构或算法来解决?

## 解决方案

- 分析题目, 不难发现这个问题包含两个子问题: 1. 判断两个字符串是否相似; 2. 将相似字符串分组
- 判断两个字符串是否相似比较简单, 只需要遍历两个字符串, 查看两者是否相等或恰好有两个位置的字符不同且交换后相同即可, 由于题目给出每个字符串都是其他字符串的字母异位词, 所以只要保证不同字符对不超过 2, 那么它们就一定相等或者交换一次后相等, 即为相似字符串
- 而将相似字符串分组, 可以使用[并查集](https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86)的思路, 将相似字符串放在同一个集合中, 我之前还写过一个并查集的系列, 感兴趣的同学在我的公众号聊天框中回复 **并查集** 就能看到了
- 具体步骤如下:
  1. 首先我们需要定义一个字典 pre, `pre[s]`表示 s 的祖先, 如果两个元素具有相同祖先, 就表示它们在同一个集合中. 可以把祖先 `pre[s]` 想象成一个树的根节点, 那么 s 就是树中的一个节点(可能是根节点本身)
  2. 然后定义一个 find 方法, 查找当前元素的祖先, 如果祖先不存在的话就把自身当做祖先. 这里用到了路径压缩的优化, 就是说当发现自己的祖先不是自身的时候, 就尝试把自己的祖先设置为自己的当前祖先的祖先, 从而降低树的高度, 加快之后的查找过程.
  3. 最后定义一个 union 方法, 用于合并两个元素. 这里的思路也很简单, 就是找到各自的祖先, 然后将其中一个的祖先的祖先设置为另外一个祖先即可, 等于就把两个树合并在了一起
- 我们通过两重循环遍历所有字符串, 如果当前字符串对相似, 就将其合并, 最终查找有多少个不同的祖先, 即为相似字符串组的个数
- 下面的代码对必要步骤有详细的解释, 方便大家理解

#### 复杂度

- 时间复杂度 `O(N^2*(C+logN))`: N 是字符串数目, C 是每个字符串的平均长度, 我们需要两重循环遍历所有字符串对(`O(N^2)`), 然后对每一对检查其是否相似(`O(C)`), 相似的话需要合并(`O(logN)`), 所以总时间复杂度就是`O(N^2*(C+logN))`
- 空间复杂度 `O(NC)`: 并查集需要存 N 个字符串, 每个字符串的平均长度是 C

#### 代码

```python
class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        ### 并查集+双重循环找相似
        pre = {}

        def find(s):
            # 查找s的祖先, 顺便进行路径压缩
            if s not in pre:
                # 当前字符串还不在pre字典中, 就初始化其祖先为字符串本身
                pre[s] = s
            elif pre[s] != s:
                # 当前字符串和祖先字符串不一样, 尝试路径压缩
                pre[s] = find(pre[s])
            return pre[s]

        def union(s1, s2):
            # 将两个字符串进行合并
            pre[find(s1)] = find(s2)

        def isSimilar(s1, s2):
            # 判断s1和s2是否相似
            diffCnt = 0
            for c1, c2 in zip(s1, s2):
                if c1 != c2:
                    diffCnt += 1
                    if diffCnt > 2:
                        # 超过两个不同, 不相似
                        return False
            # 此时说明s1和s2一定相等或者交换一次后相等, 即它们相似
            return True

        for i in range(len(strs)):
            for j in range(i + 1, len(strs)):
                s1, s2 = strs[i], strs[j]
                if isSimilar(s1, s2):
                    # 当前字符串对相似, 将其合并
                    union(s1, s2)
        # 查找有多少个不同的祖先, 即为相似字符串组的个数
        v = set()
        for s in strs:
            v.add(find(s))
        return len(v)
```

---

> 大家可以在下面这些地方找到我~😊

> [我的 GitHub](https://github.com/zjulyx)

> [我的 Leetcode](https://leetcode-cn.com/u/suibianfahui/)

> [我的 CSDN](https://me.csdn.net/zjulyx1993)

> [我的知乎专栏](https://zhuanlan.zhihu.com/c_1242508721932464128)

> [我的头条号](https://www.toutiao.com/c/user/1090304683804520/#mid=1671643017345028)

> [我的牛客网博客](https://blog.nowcoder.net/zjulyx)

> 我的公众号: [算法精选](https://mp.weixin.qq.com/s?__biz=MzA5MDk1MjI5MA==&mid=2247484158&idx=1&sn=90176bac32cf7af40e4074c721fd8a95&chksm=900285f3a7750ce5a068c9c9773781461819633f2fd60533732637ec9520c908371ebc218d49&scene=178&cur_album_id=1386231241346859009#rd), 欢迎大家扫码关注~😊

![算法精选 - 微信扫一扫关注我](https://pic1.zhimg.com/80/v2-7c988a7b35886df51596ef23616764ac_1440w.jpg)
