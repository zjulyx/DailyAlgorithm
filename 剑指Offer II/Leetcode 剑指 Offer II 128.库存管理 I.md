> 题目难度: 简单

> [原题链接](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

> 今天继续更新 Leetcode 的剑指 Offer（专项突击版）系列, 大家在公众号 **算法精选** 里回复 `剑指offer2` 就能看到该系列当前连载的所有文章了, 记得关注哦~

## 题目描述

仓库管理员以数组 stock 形式记录商品库存表。stock[i] 表示商品 id，可能存在重复。原库存表按商品 id 升序排列。现因突发情况需要进行商品紧急调拨，管理员将这批商品 id 提前依次整理至库存表最后。请你找到并返回库存表中编号的 最小的元素 以便及时记录本次调拨。

### 示例 1：

- 输入：stock = [4,5,8,3,4]
- 输出：3

### 示例 2：

- 输入：stock = [5,7,9,1,2]
- 输出：1

### 提示：

- 1 <= stock.length <= 5000
- -5000 <= stock[i] <= 5000

## 题目思考

1. 如果利用原始数组有序这一条件?

## 解决方案

### 思路

#### 分析

- 直接利用 min 或者遍历一遍求最小值也能得到结果, 但这完全没有用上原始数组有序这一条件, 所以也不是这道题目考察的本意所在
- 而数组有序一般就可以尝试二分查找来加速运算, 这道题也不例外
- 因为进行过旋转, 所以数组最多可能会有两段递增的区间, 而它们的分界点就是旋转点(当然也有可能旋转 0 个数字, 那就是自身一段递增区间)
- 基于经典二分查找, 考虑中间下标 m 对应的数字:
  1. 如果中间值小于末尾, 那么一定说明该数字之后(后半段)有序.
     - 这里可以用反证法证明: 假设此时后半段无序, 意味着分界点就在后半段, 那么前半段一定有序, 也即**中间值大于等于开头**, 而分界点又是原数组起点, 它在后半段, 这就意味着**开头一定大于等于末尾**, 综合起来就是**中间值大于等于末尾**, 正好与前提矛盾.
     - 后半段有序, 那么最小值一定是中间值或者更前面, 所以**二分进入前半段即可, 注意需要保留 m 作为候选项**
  2. 如果中间值大于末尾, 那么毫无疑问后半段无序.
     - 后半段无序, 那么一定会排除前半段. 因为根据上面的分析, 末尾此时一定小于等于开头, 开头到中间的部分都大于等于末尾, 所以**二分进入右半段即可, 这里不需要保留 m 作为候选项, 因为末尾一定小于它**
  3. 如果中间值等于末尾, 那就不好判断是前半段无序还是后半段无序了, 举两个例子大家就应该很清楚了: 前半段无序 `[2,1,2,2,2]`; 后半段无序 `[2,2,2,1,2]`
     - 这种情况由于无法判断有序, 只能退化成逐个遍历, **末尾-1 即可**. 注意此处不能是开头+1, 因为并不确定开头和中间值的关系, 有可能开头是最小值
- 根据上述三种情况, 每次区间缩小都会保留最小值作为候选项, 所以最后收敛到的值一定是最小值

#### 实现

- 经典二分查找的变种
- 定义开头下标和结尾下标 s 和 e
- 计算中间下标 m, 根据中间值与末尾值的关系来二分区间, 具体关系和上面分析完全一致
- 下面代码对必要步骤都有解释, 方便大家理解

### 复杂度

- 时间复杂度 `O(logN)~O(N)`
  - 大部分情况下 O(logN) 时间就能二分出结果, 最差情况会退化成`O(N)` (数组元素都相等时)
- 空间复杂度 `O(1)`
  - 只需要几个变量即可

### 代码

```python
class Solution:
    def inventoryManagement(self, stock: List[int]) -> int:
        # 简单二分, 当m=e时无脑直接e-1...
        # 最后返回跳出循环后的stock[s]
        # 注意m<e时要把e设为m, 因为最小值可能就是m
        s, e = 0, len(stock) - 1
        while s < e:
            m = (s + e) >> 1
            if stock[m] < stock[e]:
                # m可能是最小值, 不能排除它
                e = m
            elif stock[m] > stock[e]:
                # m一定不是最小值, 排除它
                s = m + 1
            else:
                # 退化的情况
                e -= 1
        return stock[s]
```

---

> 大家可以在下面这些地方找到我~😊

> [我的 GitHub](https://github.com/zjulyx)

> [我的 Leetcode](https://leetcode-cn.com/u/suibianfahui/)

> [我的 CSDN](https://me.csdn.net/zjulyx1993)

> [我的知乎专栏](https://zhuanlan.zhihu.com/c_1242508721932464128)

> [我的头条号](https://www.toutiao.com/c/user/1090304683804520/#mid=1671643017345028)

> [我的牛客网博客](https://blog.nowcoder.net/zjulyx)

> 我的公众号: [算法精选](https://mp.weixin.qq.com/s?__biz=MzA5MDk1MjI5MA==&mid=2247484158&idx=1&sn=90176bac32cf7af40e4074c721fd8a95&chksm=900285f3a7750ce5a068c9c9773781461819633f2fd60533732637ec9520c908371ebc218d49&scene=178&cur_album_id=1386231241346859009#rd), 欢迎大家扫码关注~😊

![算法精选 - 微信扫一扫关注我](https://pic1.zhimg.com/80/v2-7c988a7b35886df51596ef23616764ac_1440w.jpg)
