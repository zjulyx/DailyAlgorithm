> 题目难度: 困难

> [原题链接](https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

> 今天继续更新 Leetcode 的剑指 Offer（专项突击版）系列, 大家在公众号 **算法精选** 里回复 `剑指offer2` 就能看到该系列当前连载的所有文章了, 记得关注哦~

## 题目描述

请设计一个程序来支持用户在文本编辑器中的模糊搜索功能。用户输入内容中可能使用到如下两种通配符：

'.' 匹配任意单个字符。
'\*' 匹配零个或多个前面的那一个元素。

请返回用户输入内容 input 所有字符是否可以匹配原文字符串 article。

### 示例 1：

- 输入：article = "aa", input = "a"
- 输出：false
- 解释："a" 无法匹配 "aa" 整个字符串。

### 示例 2：

- 输入：article = "aa", input = "a\*"
- 输出：true
- 解释：因为 '\*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

### 示例 3：

- 输入：article = "ab", input = ".\*"
- 输出：true
- 解释："._" 表示可匹配零个或多个（'_'）任意字符（'.'）。

### 提示：

- 1 <= article.length <= 20
- 1 <= input.length <= 20
- article 只包含从 a-z 的小写字母。
- input 只包含从 a-z 的小写字母，以及字符 . 和 \_ 。
- 保证每次出现字符 \_ 时，前面都匹配到有效的字符

## 题目思考

1. 如何特殊处理`.`和`*`?

## 解决方案

### 思路

- 分析题目, 特殊字符只有`.`和`*`. `.`比较简单, 直接可以跟任何字符匹配; 而`*`则要考虑前一个字符是什么.
- 要判断两个字符串是否匹配, 最简单的做法就是双指针依次比较即可, 这里也不例外.
- 我们需要维护当前 `s` 和 `p` 的下标 `i` 和 `j`, 然后从起点开始匹配, 分为以下几种情况分析:
  1. 边界情况 1: `p` 的字符已经用完, 即 `j == len(p)`. 此时只有当 `s` 也恰好匹配完, 才表明两个字符串匹配;
  2. 边界情况 2: `s` 的字符已经用完, 即 `i == len(s)`. 这种情况下, 如果 `p` 也恰好匹配完显然匹配; 但 `p` 没有用完的时候也可能匹配. 这是因为有`*`的存在, 它和它前一个字符可以只匹配 0 次, 这就意味着只有当前 `p` 之后的字符串满足`x*x*`这样的形式就也可以匹配;
  3. 此时 `p` 和 `s` 的字符都还有剩余, 这时候不能简单比较 `s[i]` 和 `p[j]`, 这是因为有`*`的存在, 需要继续细分为两种情况:
     1. 如果 `p[j+1]` 存在且为`*`: 此时`s[i]` 可以直接跳到与`p[j+2]`匹配, 表示不用当前的`x*`组合; 当然也可以 `j` 不动而 `i` 继续后移 (前提是`s[i]` 和 `p[j]`匹配)
     2. 否则的话意味不能跳过, 必须比较 `s[i]` 和 `p[j]`, 只有`p[j]`为`.`或者和`s[i]`相等时才成功匹配.
- 注意我们在判断过程中可以将`(i, j)`组合的结果保存起来, 避免重复计算, 这就是记忆化搜索的思想
- 下面代码完全基于上述分析实现, 必要步骤都有详细注释

### 复杂度

- 时间复杂度 `O(MN)`
  - 采用了记忆化方法, 每个字符只需要计算一次匹配
- 空间复杂度 `O(MN)`
  - 需要存所有下标组合的匹配结果

### 代码

```python
class Solution:
    def articleMatch(self, s: str, p: str) -> bool:
        # 记忆化搜索
        @functools.cache
        def match(i, j):
            if j == len(p):
                # 模式串p遍历完了, 那么只有当s正好也遍历完才满足要求
                return i == len(s)
            elif i == len(s):
                # 此时意味着s遍历完了, 但模式串p仍然有值, 这时候只有当后面的模式串都是x*x*这样的形式才可以, 代表后面的x*都只匹配0次
                # 所以需要判断p[j+1]是否是*, 是的话继续递归判断(i,j+2)组合, 否则直接返回False
                return j + 1 < len(p) and p[j + 1] == "*" and match(i, j + 2)
            else:
                # 意味着s和p都没遍历完
                if j + 1 < len(p) and p[j + 1] == "*":
                    # 下一个p字符是*, 存在两种情况:
                    # 1. 当前字符可以不使用
                    # 2. 如果当前字符恰好匹配的话, 也可以使用它, j位置保持不变, i后移
                    return match(i, j + 2) or ((s[i] == p[j] or p[j] == ".") and match(i + 1, j))
                else:
                    # 下一个p字符不是*, 必须老老实实根据当前字符匹配了
                    return (s[i] == p[j] or p[j] == ".") and match(i + 1, j + 1)

        return match(0, 0)
```

---

> 大家可以在下面这些地方找到我~😊

> [我的 GitHub](https://github.com/zjulyx)

> [我的 Leetcode](https://leetcode-cn.com/u/suibianfahui/)

> [我的 CSDN](https://me.csdn.net/zjulyx1993)

> [我的知乎专栏](https://zhuanlan.zhihu.com/c_1242508721932464128)

> [我的头条号](https://www.toutiao.com/c/user/1090304683804520/#mid=1671643017345028)

> [我的牛客网博客](https://blog.nowcoder.net/zjulyx)

> 我的公众号: [算法精选](https://mp.weixin.qq.com/s?__biz=MzA5MDk1MjI5MA==&mid=2247484158&idx=1&sn=90176bac32cf7af40e4074c721fd8a95&chksm=900285f3a7750ce5a068c9c9773781461819633f2fd60533732637ec9520c908371ebc218d49&scene=178&cur_album_id=1386231241346859009#rd), 欢迎大家扫码关注~😊

![算法精选 - 微信扫一扫关注我](https://pic1.zhimg.com/80/v2-7c988a7b35886df51596ef23616764ac_1440w.jpg)
