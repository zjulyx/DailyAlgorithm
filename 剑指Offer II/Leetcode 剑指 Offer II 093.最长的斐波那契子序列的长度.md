> 题目难度: 中等

> [原题链接](https://leetcode.cn/problems/Q91FMA/)

> 今天继续更新 Leetcode 的剑指 Offer（专项突击版）系列, 大家在公众号 **算法精选** 里回复 `剑指offer2` 就能看到该系列当前连载的所有文章了, 记得关注哦~

## 题目描述

如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的：

- n >= 3
- 对于所有 i + 2 <= n，都有 `X_i + X_{i+1} = X_{i+2}`

给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。

（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）

### 示例 1：

- 输入: arr = [1,2,3,4,5,6,7,8]
- 输出: 5
- 解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。

### 示例 2：

- 输入: arr = [1,3,7,11,12,14,18]
- 输出: 3
- 解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。

### 提示：

- 3 <= arr.length <= 1000
- 1 <= arr[i] < arr[i + 1] <= 10^9

## 题目思考

1. 如何尽可能优化时间复杂度?

## 解决方案

- 分析题目, 一个很容易想到的思路是固定开头的两个数字, 然后检查两数之和是否存在于数组中, 是的话将其作为新的数字, 继续向后检查
- 这里需要使用一个集合存储数组的所有值, 这样可以快速判断两数之和是否存在, 不过这种做法的时间复杂度达到了 O(N^3) (两重循环 O(N^2)固定开头, 内部 O(N)向后检查新数字), 有没有更优的做法呢?
- 不难发现, 上面的思路进行了大量的重复计算, 因为当两开头之和存在于数组中时, 我们会重复计算以`(第二个开头, 两开头之和)`作为开头的子序列, 如果我们能提前记录这部分, 就可以避免重复计算
- 举个例子, 对于数组`[1,2,3,4,5,6,7,8]`, 假设当前遍历到的开头两个数字分别是 2 和 3, 其数字之和是 5, 那么如果我们提前计算好了以 3 和 5 开头的最长子序列长度, 那么 2 和 3 开头的子序列自然就是那个长度加 1 (即加上新的开头 2)
- 这就是典型的动态规划的思想, 我们可以从后往前进行两重循环, 使用二维 dp 数组记录开头两下标时的最长子序列长度, 然后如果两数之和对应的下标存在于数组中, 则更新当前 dp 值为那个 dp 值加 1
- 用数学语言来表示, 假设`dp[i][j]`分别代表以`arr[i]`和`arr[j]`作为开头两个数字时的最长子序列长度, 那么就有:
  - `if arr[i]+arr[j] in arr and its index is k: dp[i][j]=dp[j][k]+1`
  - `else: dp[i][j]=2`
- 然后由于有效子序列要求长度至少为 3, 所以只有当 dp 值大于等于 3 时才更新最终结果
- 另外我们需要快速得到某个值是否在数组中以及其对应下标, 我们可以使用一个下标字典, 存储数组值到其下标的映射关系, 因为题目给出的数组是严格递增的, 所以每个数字都不重复, 没有重复 key 的问题
- 下面的代码中有详细的注释, 方便大家理解

#### 复杂度

- 时间复杂度 `O(N^2)`: 需要两重遍历数组
- 空间复杂度 `O(N^2)`: 二维 DP 数组的空间消耗

#### 代码

```python
class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        ### 二维DP+循环开头ij+下标字典求k
        n = len(arr)
        # {x:i}下标字典
        d = {x: i for i, x in enumerate(arr)}
        # dp[i][j]存储开头两位是下标i和j的最大长度, 初始值都是2, 因为至少有两个元素
        dp = [[2] * n for _ in range(n)]
        res = 0
        for i in range(n)[::-1]:
            for j in range(i + 1, n)[::-1]:
                # 注意i和j都需要逆序遍历, 这样才能保证后续序列的dp值已经被计算好
                # 计算得到下一位的数字, 如果存在于下标字典中, 则更新长度
                nex = arr[i] + arr[j]
                if nex in d:
                    # 存在后续子序列, 使用对应dp值加1
                    k = d[nex]
                    dp[i][j] = dp[j][k] + 1
                if dp[i][j] >= 3:
                    # 只有长度至少为3时才是有效的子序列
                    res = max(res, dp[i][j])
        return res
```

---

> 大家可以在下面这些地方找到我~😊

> [我的 GitHub](https://github.com/zjulyx)

> [我的 Leetcode](https://leetcode-cn.com/u/suibianfahui/)

> [我的 CSDN](https://me.csdn.net/zjulyx1993)

> [我的知乎专栏](https://zhuanlan.zhihu.com/c_1242508721932464128)

> [我的头条号](https://www.toutiao.com/c/user/1090304683804520/#mid=1671643017345028)

> [我的牛客网博客](https://blog.nowcoder.net/zjulyx)

> 我的公众号: [算法精选](https://mp.weixin.qq.com/s?__biz=MzA5MDk1MjI5MA==&mid=2247484158&idx=1&sn=90176bac32cf7af40e4074c721fd8a95&chksm=900285f3a7750ce5a068c9c9773781461819633f2fd60533732637ec9520c908371ebc218d49&scene=178&cur_album_id=1386231241346859009#rd), 欢迎大家扫码关注~😊

![算法精选 - 微信扫一扫关注我](https://pic1.zhimg.com/80/v2-7c988a7b35886df51596ef23616764ac_1440w.jpg)
